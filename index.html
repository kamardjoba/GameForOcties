<!DOCTYPE HTML>
<html lang="en-US">
<head>
    <title>Jump</title>
    <link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet">
    <link rel="stylesheet" href="./game.css">
    <script src="./JS/scripts.js"></script>
</head>
<body>

    <div class="container">
        <canvas id="canvas">
            Aww, your browser doesn't support HTML5!
        </canvas>

        <div id="mainMenu">
            <h1>Doodle Jump</h1>
            <h3>Using HTML5,</h3>
            <h3>...from <a href="https://codepen.io/FRADAR" target="_blank">FRADAR</a></h3>

            <p class="info">
                Use
                <span class="key left">←</span>
                <span class="key right">→</span>
                for moving and (re)start the game
            </p>
            <a class="button" href="javascript:init()">Play</a>
        </div>
        
        <div id="gameOverMenu">
            <h1>Game Over!</h1>
            <h3 id="go_score">You have 0 scores</h3>

            <a class="button" href="javascript:reset()">Restart</a>
            <a id="tweetBtn" target="_blank" class="button tweet" href="#">Tweet results</a>

            <a id="fbBtn" target="_blank" class="button fb" href="#">Post on Facebook</a>
        </div>
        
        <!-- Предзагрузка изображений -->
        <img id="sprite" src="./Img/undefined - Imgur-2.png" style="display: none;"/>
        <img id="enemyStatic" src="./Img/enemy.png" style="display: none;"/> <!-- Статический противник -->
        <img id="enemyMoving" src="./Img/enemy_moving.png" style="display: none;"/> <!-- Движущийся противник -->
        <img id="enemyScreen" src="./Img/movingenemy.png" style="display: none;"/> <!-- Новый движущийся противник -->

        <div id="scoreBoard">
            <p id="score">0</p>
        </div>
    </div>

    <script>
        // RequestAnimFrame: браузерный API для плавных анимаций
        window.requestAnimFrame = (function() {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();

        // Получаем элемент canvas
        var canvas = document.getElementById('canvas'),
            ctx = canvas.getContext('2d');

        // Функция для изменения размеров canvas на весь экран
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Вызов функции для обновления размеров холста
        resizeCanvas();

        // Изменение размеров при изменении размеров окна
        window.addEventListener('resize', resizeCanvas);

        // Основные переменные игры
        var width = canvas.width,
            height = canvas.height;

        var coinImage = new Image();
        coinImage.src = './Img/coin.png'; // Убедитесь, что путь к изображению правильный

        var platforms = [],
            image = document.getElementById("sprite"),
            enemyStaticImage = document.getElementById("enemyStatic"),
            enemyMovingImage = document.getElementById("enemyMoving"),
            enemyScreenImage = document.getElementById("enemyScreen"),
            player,
            platformCount = 10,
            position = 0,
            gravity = 0.2,
            animloop,
            flag = 0,
            broken = 0,
            dir,
            score = 0,
            firstRun = true;

        var screenEnemies = []; // Список ScreenEnemy

        // Объект базы
        var Base = function() {
            this.height = 5;
            this.width = width;

            // Обрезка спрайта
            this.cx = 0;
            this.cy = 614;
            this.cwidth = 100;
            this.cheight = 5;

            this.moved = 0;

            this.x = 0;
            this.y = height - this.height;

            this.draw = function() {
                try {
                    ctx.drawImage(image, this.cx, this.cy, this.cwidth, this.cheight, this.x, this.y, this.width, this.height);
                } catch (e) {}
            };
        };

        var base = new Base();

        // Класс монеты
        function Coin(platform) {
            this.width = 30; // ширина монеты
            this.height = 30; // высота монеты

            this.platform = platform; // ссылка на платформу

            this.collected = false; // статус сбора

            this.draw = function() {
                if (!this.collected) {
                    // Расчет позиции монеты относительно платформы
                    let x = this.platform.x + (this.platform.width - this.width) / 2;
                    let y = this.platform.y - this.height - 10;
                    try {
                        ctx.drawImage(coinImage, x, y, this.width, this.height);
                    } catch (e) {
                        console.error('Ошибка при отрисовке монеты:', e);
                    }
                }
            };

            this.collect = function() {
                this.collected = true;
                score += 100; // добавляем 100 очков за сбор монеты
                // Опционально: добавить звук или анимацию сбора монеты
                console.log('Монета собрана! Очки:', score);
            };
        }

        // Класс Статического Противника
        function StaticEnemy(platform) {
            this.width = 40; // ширина противника
            this.height = 40; // высота противника

            this.platform = platform; // ссылка на платформу

            // Позиция противника относительно платформы
            this.x = this.platform.x + (this.platform.width - this.width) / 2;
            this.y = this.platform.y - this.height - 10;

            // Загрузка изображения статического противника
            this.image = enemyStaticImage;

            this.draw = function() {
                try {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } catch (e) {
                    console.error('Ошибка при отрисовке статического противника:', e);
                }
            };

            // Метод обновления позиции (нет необходимости для статического противника)
            this.update = function() {
                // Обновляем позицию относительно платформы
                this.x = this.platform.x + (this.platform.width - this.width) / 2;
                this.y = this.platform.y - this.height - 10;
            };
        }

        // Класс Движущегося Противника
        function MovingEnemy(platform) {
            this.width = 40; // ширина противника
            this.height = 40; // высота противника

            this.platform = platform; // ссылка на платформу

            // Начальная позиция движущегося противника относительно платформы
            this.x = platform.x; // Начинает с левого края платформы
            this.y = platform.y - this.height - 10; // На платформе

            // Скорость движения противника
            this.vx = 3;

            // Направление движения: 1 - вправо, -1 - влево
            this.direction = 1;

            // Загрузка изображения движущегося противника
            this.image = enemyMovingImage;

            this.draw = function() {
                try {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } catch (e) {
                    console.error('Ошибка при отрисовке движущегося противника:', e);
                }
            };

            this.update = function() {
                // Движение противника
                this.x += this.vx * this.direction;

                // Проверка границ платформы
                if (this.x <= this.platform.x || this.x + this.width >= this.platform.x + this.platform.width) {
                    this.direction *= -1; // смена направления
                }

                // Обновление позиции относительно платформы
                this.y = this.platform.y - this.height - 10;
            };
        }

        // Класс СкринПротивника (ScreenEnemy)
        function ScreenEnemy() {
            this.width = 40; // Ширина противника
            this.height = 40; // Высота противника

            // Определяем, с какой стороны начинается противник
            this.direction = Math.random() < 0.5 ? 'left' : 'right';
            if (this.direction === 'left') {
                this.x = 0 - this.width; // Начинает с левого края экрана
                this.vx = 3; // Скорость вправо
            } else {
                this.x = width; // Начинает с правого края экрана
                this.vx = -3; // Скорость влево
            }

            // Случайная y-позиция, чтобы противник не был слишком близко к верхнему или нижнему краю
            this.y = Math.random() * (height - 100) + 50;

            // Загрузка изображения ScreenEnemy
            this.image = enemyScreenImage; // Предзагруженное изображение

            this.draw = function() {
                try {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } catch (e) {
                    console.error('Ошибка при отрисовке ScreenEnemy:', e);
                }
            };

            this.update = function() {
                this.x += this.vx;

                // Разворот при достижении края экрана
                if (this.direction === 'left' && this.x + this.width >= width) {
                    this.direction = 'right';
                    this.vx = -this.vx; // Меняем направление движения
                } else if (this.direction === 'right' && this.x <= 0 - this.width) {
                    this.direction = 'left';
                    this.vx = -this.vx; // Меняем направление движения
                }

                // Удаляем противника, если он полностью вышел за пределы экрана (для оптимизации)
                if ((this.direction === 'left' && this.x > width + this.width) ||
                    (this.direction === 'right' && this.x < -this.width)) {
                    this.toRemove = true;
                }
            };
        }

        // Класс игрока
        var Player = function() {
            this.vy = 11;
            this.vx = 0;

            this.isMovingLeft = false;
            this.isMovingRight = false;
            this.isDead = false;

            this.width = 55;
            this.height = 40;

            // Обрезка спрайта
            this.cx = 0;
            this.cy = 0;
            this.cwidth = 110;
            this.cheight = 80;

            this.dir = "left";

            this.x = width / 2 - this.width / 2;
            this.y = height;

            // Функция отрисовки
            this.draw = function() {
                try {
                    if (this.dir == "right") this.cy = 121;
                    else if (this.dir == "left") this.cy = 201;
                    else if (this.dir == "right_land") this.cy = 289;
                    else if (this.dir == "left_land") this.cy = 371;

                    ctx.drawImage(image, this.cx, this.cy, this.cwidth, this.cheight, this.x, this.y, this.width, this.height);
                } catch (e) {}
            };

            this.jump = function() {
                this.vy = -8;
            };

            this.jumpHigh = function() {
                this.vy = -16;
            };
        };

        player = new Player();

        // Класс платформы
        function Platform() {
            this.width = 70;
            this.height = 17;

            this.x = Math.random() * (width - this.width);
            this.y = position;

            position += (height / platformCount);

            this.flag = 0;
            this.state = 0;

            // Обрезка спрайта
            this.cx = 0;
            this.cy = 0;
            this.cwidth = 105;
            this.cheight = 31;

            // Возможные типы платформ
            if (score >= 5000) this.types = [2, 3, 3, 3, 4, 4, 4, 4];
            else if (score >= 2000 && score < 5000) this.types = [2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4];
            else if (score >= 1000 && score < 2000) this.types = [2, 2, 2, 3, 3, 3, 3, 3];
            else if (score >= 500 && score < 1000) this.types = [1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3];
            else if (score >= 100 && score < 500) this.types = [1, 1, 1, 1, 2, 2];
            else this.types = [1];

            this.type = this.types[Math.floor(Math.random() * this.types.length)];

            // Ограничение на количество подряд идущих ломаемых платформ
            if (this.type == 3 && broken < 1) {
                broken++;
            } else if (this.type == 3 && broken >= 1) {
                this.type = 1;
                broken = 0;
            }

            this.moved = 0;
            this.vx = 1;

            // Привязка монеты к платформе с 50% вероятностью
            if (Math.random() < 0.5) { // 50% вероятность
                this.coin = new Coin(this);
            }

            // Привязка статического противника к платформе с 20% вероятностью
            this.hasStaticEnemy = Math.random() < 0.2;
            if (this.hasStaticEnemy) {
                this.staticEnemy = new StaticEnemy(this);
            }

            // Привязка движущегося противника к платформе с 10% вероятностью
            this.hasMovingEnemy = Math.random() < 0.1;
            if (this.hasMovingEnemy) {
                this.movingEnemy = new MovingEnemy(this);
            }

            this.draw = function() {
                try {
                    if (this.type == 1) this.cy = 0;
                    else if (this.type == 2) this.cy = 61;
                    else if (this.type == 3 && this.flag === 0) this.cy = 31;
                    else if (this.type == 3 && this.flag == 1) this.cy = 1000;
                    else if (this.type == 4 && this.state === 0) this.cy = 90;
                    else if (this.type == 4 && this.state == 1) this.cy = 1000;

                    ctx.drawImage(image, this.cx, this.cy, this.cwidth, this.cheight, this.x, this.y, this.width, this.height);

                    // Рисуем монету, если она существует и не собрана
                    if (this.coin && !this.coin.collected) {
                        this.coin.draw();
                    }

                    // Рисуем статического противника, если он есть
                    if (this.hasStaticEnemy && this.staticEnemy) {
                        this.staticEnemy.draw();
                    }

                    // Рисуем движущегося противника, если он есть
                    if (this.hasMovingEnemy && this.movingEnemy) {
                        this.movingEnemy.draw();
                    }
                } catch (e) {
                    console.error('Ошибка при отрисовке платформы, монеты или противника:', e);
                }
            };

            this.update = function() {
                // Обновляем платформу
                if (this.type == 2) {
                    if (this.x < 0 || this.x + this.width > width) this.vx *= -1;

                    this.x += this.vx;
                }

                // Обновляем статического противника
                if (this.hasStaticEnemy && this.staticEnemy) {
                    this.staticEnemy.update();
                }

                // Обновляем движущегося противника
                if (this.hasMovingEnemy && this.movingEnemy) {
                    this.movingEnemy.update();
                }
            };
        }

        for (var i = 0; i < platformCount; i++) {
            platforms.push(new Platform());
        }

        // Объект сломанной платформы
        var Platform_broken_substitute = function() {
            this.height = 30;
            this.width = 70;

            this.x = 0;
            this.y = 0;

            // Обрезка спрайта
            this.cx = 0;
            this.cy = 554;
            this.cwidth = 105;
            this.cheight = 60;

            this.appearance = false;

            this.draw = function() {
                try {
                    if (this.appearance === true) ctx.drawImage(image, this.cx, this.cy, this.cwidth, this.cheight, this.x, this.y, this.width, this.height);
                    else return;
                } catch (e) {}
            };
        };

        var platform_broken_substitute = new Platform_broken_substitute();

        // Класс пружины
        var spring = function() {
            this.x = 0;
            this.y = 0;

            this.width = 26;
            this.height = 30;

            // Обрезка спрайта
            this.cx = 0;
            this.cy = 0;
            this.cwidth = 45;
            this.cheight = 53;

            this.state = 0;

            this.draw = function() {
                try {
                    if (this.state === 0) this.cy = 445;
                    else if (this.state == 1) this.cy = 501;

                    ctx.drawImage(image, this.cx, this.cy, this.cwidth, this.cheight, this.x, this.y, this.width, this.height);
                } catch (e) {}
            };
        };

        var Spring = new spring();

        // Функция инициализации игры
        function init() {
            // Переменные для игры
            var dir = "left",
                jumpCount = 0;
            
            firstRun = false;
            // Удалите или закомментируйте следующую строку
            // coins = [];

            screenEnemies = []; // Инициализация списка ScreenEnemy

            // Функция очистки холста
            function paintCanvas() {
                ctx.clearRect(0, 0, width, height);
            }

            // Функция вычислений и логики игрока
            function playerCalc() {
                if (dir == "left") {
                    player.dir = "left";
                    if (player.vy < -7 && player.vy > -15) player.dir = "left_land";
                } else if (dir == "right") {
                    player.dir = "right";
                    if (player.vy < -7 && player.vy > -15) player.dir = "right_land";
                }

                // Обработчики нажатий клавиш
                document.onkeydown = function(e) {
                    var key = e.keyCode;
                    
                    if (key == 37) { // Влево
                        dir = "left";
                        player.isMovingLeft = true;
                    } else if (key == 39) { // Вправо
                        dir = "right";
                        player.isMovingRight = true;
                    }
                    
                    if(key == 32) { // Пробел
                        if(firstRun === true)
                            init();
                        else 
                            reset();
                    }
                };

                document.onkeyup = function(e) {
                    var key = e.keyCode;
                
                    if (key == 37) { // Влево
                        dir = "left";
                        player.isMovingLeft = false;
                    } else if (key == 39) { // Вправо
                        dir = "right";
                        player.isMovingRight = false;
                    }
                };
                
                // Обработка касаний
                document.removeEventListener('touchstart', handleTouchStart, false);
                document.removeEventListener('touchend', handleTouchEnd, false);
                document.addEventListener('touchstart', handleTouchStart, false);
                document.addEventListener('touchend', handleTouchEnd, false);

                function handleTouchStart(evt) {
                    let touchX = evt.touches[0].clientX;
                    
                    if (touchX < window.innerWidth / 2) {
                        // Касание левой половины экрана - движение влево
                        dir = "left";
                        player.isMovingLeft = true;
                        player.isMovingRight = false;
                    } else {
                        // Касание правой половины экрана - движение вправо
                        dir = "right";
                        player.isMovingRight = true;
                        player.isMovingLeft = false;
                    }
                }

                function handleTouchEnd() {
                    // Остановка движения при убирании пальца с экрана
                    player.isMovingLeft = false;
                    player.isMovingRight = false;
                }

                // Ускорение при удерживании клавиш
                if (player.isMovingLeft === true) {
                    player.vx -= 0.15;
                } else {
                    if (player.vx < 0) player.vx += 0.1;
                }

                if (player.isMovingRight === true) {
                    player.vx += 0.15;
                } else {
                    if (player.vx > 0) player.vx -= 0.1;
                }

                // Ограничение скорости
                if(player.vx > 8)
                    player.vx = 8;
                else if(player.vx < -8)
                    player.vx = -8;

                // Обновление позиции игрока
                player.x += player.vx;

                // Прыжок игрока при столкновении с базой
                if ((player.y + player.height) > base.y && base.y < height) player.jump();

                // Игра окончена, если игрок касается нижней части экрана
                if (base.y > height && (player.y + player.height) > height && player.isDead != "lol") player.isDead = true;

                // Проход через стены
                if (player.x > width) player.x = 0 - player.width;
                else if (player.x < 0 - player.width) player.x = width;

                // Движение игрока под действием гравитации
                if (player.y >= (height / 2) - (player.height / 2)) {
                    player.y += player.vy;
                    player.vy += gravity;
                }

                // Когда игрок достигает половины высоты экрана, движем платформы для создания иллюзии прокрутки
                else {
                    platforms.forEach(function(p, i) {

                        if (player.vy < 0) {
                            p.y -= player.vy;
                            // Обновляем только y позицию платформы
                            // Статические противники будут обновлять свои позиции с платформой
                            // Движущиеся противники обновляют только x
                        }

                        if (p.y > height) {
                            platforms[i] = new Platform();
                            platforms[i].y = p.y - height;
                        }

                    });

                    base.y -= player.vy;
                    player.vy += gravity;

                    if (player.vy >= 0) {
                        player.y += player.vy;
                        player.vy += gravity;
                    }

                    score++;
                }

                // Столкновения с платформами и пружинами
                collides();

                if (player.isDead === true) gameOver();
            }

            // Алгоритмы пружины
            function springCalc() {
                var s = Spring;
                var p = platforms[0];

                if (p.type == 1 || p.type == 2) {
                    s.x = p.x + p.width / 2 - s.width / 2;
                    s.y = p.y - p.height - 10;

                    if (s.y > height / 1.1) s.state = 0;

                    s.draw();
                } else {
                    s.x = 0 - s.width;
                    s.y = 0 - s.height;
                }
            }

            // Алгоритм горизонтального движения платформ
            function platformCalc() {
                var subs = platform_broken_substitute;

                platforms.forEach(function(p, i) {
                    p.update(); // Обновляем платформу и противников

                    if (p.type == 2) {
                        // Уже обработано в методе update()
                    }

                    if (p.flag == 1 && subs.appearance === false && jumpCount === 0) {
                        subs.x = p.x;
                        subs.y = p.y;
                        subs.appearance = true;

                        jumpCount++;
                    }

                    p.draw();
                });

                if (subs.appearance === true) {
                    subs.draw();
                    subs.y += 8;
                }

                if (subs.y > height) subs.appearance = false;
            }

            // Функция столкновений
            function collides() {
                // Столкновения с платформами
                platforms.forEach(function(p, i) {
                    if (player.vy > 0 && p.state === 0 &&
                        (player.x + 15 < p.x + p.width) &&
                        (player.x + player.width - 15 > p.x) &&
                        (player.y + player.height > p.y) &&
                        (player.y + player.height < p.y + p.height)) {

                        if (p.type == 3 && p.flag === 0) {
                            p.flag = 1;
                            jumpCount = 0;
                            return;
                        } else if (p.type == 4 && p.state === 0) {
                            player.jump();
                            p.state = 1;
                        } else if (p.flag == 1) return;
                        else {
                            player.jump();
                        }
                    }
                });

                // Столкновения с пружинами
                var s = Spring;
                if (player.vy > 0 && (s.state === 0) && 
                    (player.x + 15 < s.x + s.width) && 
                        (player.x + player.width - 15 > s.x) && 
                            (player.y + player.height > s.y) && 
                                (player.y + player.height < s.y + s.height)) {
                    s.state = 1;
                    player.jumpHigh();
                }

                // Столкновения с монетами
                platforms.forEach(function(p) {
                    if (p.coin && !p.coin.collected) {
                        // Расчет позиции монеты относительно платформы
                        let coinX = p.x + (p.width - p.coin.width) / 2;
                        let coinY = p.y - p.coin.height - 10;

                        if (
                            player.x < coinX + p.coin.width &&
                            player.x + player.width > coinX &&
                            player.y < coinY + p.coin.height &&
                            player.y + player.height > coinY
                        ) {
                            p.coin.collect();
                        }
                    }
                });

                // Столкновения с статическими противниками
                platforms.forEach(function(p) {
                    if (p.hasStaticEnemy && p.staticEnemy) {
                        if (checkCollision(player, p.staticEnemy)) {
                            player.isDead = true;
                        }
                    }
                });

                // Столкновения с движущимися противниками
                platforms.forEach(function(p) {
                    if (p.hasMovingEnemy && p.movingEnemy) {
                        if (checkCollision(player, p.movingEnemy)) {
                            player.isDead = true;
                        }
                    }
                });

                // Столкновения с ScreenEnemy
                screenEnemies.forEach(function(se) {
                    if (checkCollision(player, se)) {
                        player.isDead = true;
                    }
                });
            }

            // Функция проверки столкновения
            function checkCollision(player, enemy) {
                return (
                    player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y
                );
            }

            // Функция обновления счета
            function updateScore() {
                var scoreText = document.getElementById("score");
                scoreText.innerHTML = score;
            }

            // Функция окончания игры
            function gameOver() {
                platforms.forEach(function(p, i) {
                    p.y -= 12;
                });

                if(player.y > height/2 && flag === 0) {
                    player.y -= 8;
                    player.vy = 0;
                } 
                else if(player.y < height / 2) flag = 1;
                else if(player.y + player.height > height) {
                    showGoMenu();
                    hideScore();
                    player.isDead = "lol";

                    var tweet = document.getElementById("tweetBtn");
                    tweet.href='https://twitter.com/share?url=http://is.gd/PnFFzu&text=I just scored ' +score+ ' points in the HTML5 Doodle Jump game!&count=horiztonal&via=cssdeck&related=solitarydesigns';
                
                    var facebook = document.getElementById("fbBtn");
                    facebook.href='https://facebook.com/sharer.php?s=100&p[url]=http://cssdeck.com/labs/html5-doodle-jump/8&p[title]=I just scored ' +score+ ' points in the HTML5 Doodle Jump game!&p[summary]=Can you beat me in this awesome recreation of Doodle Jump created in HTML5?';
                }
            }

            // Функция обновления всех элементов
            function update() {
                paintCanvas();
                platformCalc();
                springCalc();
                playerCalc();
                player.draw();
                base.draw();
                updateScore();

                // Спавн нового ScreenEnemy с определенной вероятностью
                if (Math.random() < 0.005) { // 0.5% вероятность
                    screenEnemies.push(new ScreenEnemy());
                }

                // Обновление и отрисовка ScreenEnemy
                for (var i = screenEnemies.length - 1; i >= 0; i--) {
                    screenEnemies[i].update();
                    screenEnemies[i].draw();

                    // Проверка столкновения с игроком
                    if (checkCollision(player, screenEnemies[i])) {
                        player.isDead = true;
                    }

                    // Удаление противника, если он вышел за пределы экрана
                    if (screenEnemies[i].toRemove) {
                        screenEnemies.splice(i, 1);
                    }
                }
            }

            animloop = function() {
                update();
                requestAnimFrame(animloop);
            };

            animloop();

            hideMenu();
            showScore();
        }

        // Функция сброса игры
        function reset() {
            hideGoMenu();
            showScore();
            player.isDead = false;
            
            flag = 0;
            position = 0;
            score = 0;

            base = new Base();
            player = new Player();
            Spring = new spring();
            platform_broken_substitute = new Platform_broken_substitute();

            platforms = [];
            screenEnemies = []; // Сброс списка ScreenEnemy
            for (var i = 0; i < platformCount; i++) {
                platforms.push(new Platform());
            }
            // Удалите или закомментируйте следующую строку
            // coins = [];
        }

        // Функции управления меню
        function hideMenu() {
            var menu = document.getElementById("mainMenu");
            menu.style.zIndex = -1;
            menu.style.visibility = "hidden";
        }

        function showGoMenu() {
            var menu = document.getElementById("gameOverMenu");
            menu.style.zIndex = 1;
            menu.style.visibility = "visible";

            var scoreText = document.getElementById("go_score");
            scoreText.innerHTML = "Вы набрали " + score + " очков!";
        }

        function hideGoMenu() {
            var menu = document.getElementById("gameOverMenu");
            menu.style.zIndex = -1;
            menu.style.visibility = "hidden";
        }

        function showScore() {
            var menu = document.getElementById("scoreBoard");
            menu.style.zIndex = 1;
        }

        function hideScore() {
            var menu = document.getElementById("scoreBoard");
            menu.style.zIndex = -1;
        }

        // Запуск меню
        // Если хотите запустить отдельный цикл для меню перед началом игры, можно раскомментировать следующую строку
        // Но в данном случае, цикл игры запускается через init(), поэтому дополнительный цикл не нужен
        // menuLoop = function() { ... };
    </script>
</body>
</html>